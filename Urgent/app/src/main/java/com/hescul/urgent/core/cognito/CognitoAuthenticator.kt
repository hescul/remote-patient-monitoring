package com.hescul.urgent.core.cognito

import android.content.Context
import com.amazonaws.AmazonClientException
import com.amazonaws.AmazonServiceException
import com.amazonaws.ClientConfiguration
import com.amazonaws.auth.CognitoCachingCredentialsProvider
import com.amazonaws.mobileconnectors.cognitoidentityprovider.*
import com.amazonaws.mobileconnectors.cognitoidentityprovider.continuations.AuthenticationContinuation
import com.amazonaws.mobileconnectors.cognitoidentityprovider.continuations.ChallengeContinuation
import com.amazonaws.mobileconnectors.cognitoidentityprovider.continuations.MultiFactorAuthenticationContinuation
import com.amazonaws.mobileconnectors.cognitoidentityprovider.handlers.*
import com.amazonaws.services.cognitoidentity.AmazonCognitoIdentityClient
import com.amazonaws.services.cognitoidentity.model.GetIdRequest
import com.amazonaws.services.cognitoidentityprovider.model.SignUpResult
import timber.log.Timber
import java.lang.Exception

class CognitoAuthenticator {
    companion object {
        private const val DEBUG_TAG = "authCognito"
        private const val DEFAULT_SIGNUP_FAIL_CAUSE = "Sign-up failed"
        private const val DEFAULT_CONFIRM_SIGNUP_FAIL_CAUSE = "Confirmation failed"
        private const val DEFAULT_SIGN_IN_FAIL_CAUSE = "Sign-in failed"
        private const val DEFAULT_RESEND_CONFIRMATION_FAIL_CAUSE = "Resend failed"
        private const val DEFAULT_GET_IDENTITY_FAIL_CAUSE = "Failed to obtain identity id"
        private const val DEFAULT_GET_ATTRIBUTES_FAIL_CAUSE = "Failed to fetch user attributes"
        private const val FAIL_CAUSE_DELIMITER = '.'
        private val FAIL_CAUSE_REPLACE_CHARS = listOf(':', '(')

        /**
         * Create a [CognitoUserPool] object for further activities with the Amazon Cognito.
         * The user pool configurations must be set in the companion [CognitoConfig] object
         *
         * @param context the application context
         * @return an [CognitoUserPool] instance
         */
        @JvmStatic
        private fun createUserPool(context: Context) = CognitoUserPool(
            context,
            CognitoConfig.USER_POOL_ID,
            CognitoConfig.CLIENT_ID,
            CognitoConfig.CLIENT_SECRET,
            ClientConfiguration(),
            CognitoConfig.USER_POOL_REGION
        )

        /**
         * Returns the stripped-down version of the failed message. Normally, the failed
         * message generated by the AWS api is lengthy and can not be displayed directly to
         * the user.
         *
         * @param cause the raw message
         * @return the stripped-down message
         */
        @JvmStatic
        fun reduceFailCause(cause: String): String {
            var reducedCause = cause
            for (chr in FAIL_CAUSE_REPLACE_CHARS) {
                reducedCause = reducedCause.replace(chr, FAIL_CAUSE_DELIMITER)
            }
            return reducedCause.substringBefore(FAIL_CAUSE_DELIMITER).trimEnd()
        }

        /**
         * Sign up a user for the user pool defined in [CognitoConfig]. The function is invoked
         * in background and will trigger the corresponding callback upon completion.
         *
         * @param context the application context
         * @param userId the main method that is used to sign up the user (eg. email address, phone number, ...)
         * @param password the user's custom password that satisfied the user pool requirement for password
         * @param userAttributes the attributes that the user pool requires
         * @param onSignUpSuccess will be called upon a successful sign-up. A [CognitoUser] and a [SignUpResult]
         * will be returned through the interface's parameter
         * @param onSignUpFailure will be called with a fail message string when the sign-up fails
         * @param defaultFailCause this message is used when the fail cause is unknown
         */
        @JvmStatic
        fun requestSignUp(
            context: Context,
            userId: String,
            password: String,
            userAttributes: CognitoUserAttributes,
            onSignUpSuccess: (CognitoUser, SignUpResult) -> Unit,
            onSignUpFailure: (String) -> Unit,
            defaultFailCause: String = DEFAULT_SIGNUP_FAIL_CAUSE,
        ) {
            // create a cognito user pool
            val userPool = createUserPool(context)

            // set up callback
            val signUpCallback = object : SignUpHandler {
                override fun onSuccess(user: CognitoUser?, result: SignUpResult?) {
                    // Sign-up was successful
                    Timber.tag(DEBUG_TAG).d("user has successfully signed up: user_id<${user?.userId}>")
                    if (user == null || result == null) {
                        onSignUpFailure(defaultFailCause)
                    } else {
                        onSignUpSuccess(user, result)
                    }

                }

                override fun onFailure(exception: Exception?) {
                    // Sign-up failed, check exception for the cause
                    Timber.tag(DEBUG_TAG).e("sign-up failed: ${exception?.message}!")
                    val failCause = exception?.message ?: defaultFailCause
                    onSignUpFailure(failCause)
                }

            }

            // do sign up in background
            userPool.signUpInBackground(userId, password, userAttributes, null, signUpCallback)
        }

        /**
         * Request confirmation for the [userId] with the supplied [confirmationCode]. The function is
         * invoked in background and will trigger callbacks upon completion.
         *
         * @param context the application context
         * @param userId the user to whom the server confirms the sign-up
         * @param confirmationCode the confirmation sent to user
         * @param forcedAliasCreation when set to false, the server will cause the confirmation to fail
         * if the user attribute has been verified for another user in the same pool
         * @param onConfirmSuccess triggered on successful confirmation
         * @param onConfirmFailure triggered with a failed message on confirmation failure
         * @param defaultFailCause this message is used when the fail cause is unknown
         */
        @JvmStatic
        fun requestConfirmSignUp(
            context: Context,
            userId: String,
            confirmationCode: String,
            forcedAliasCreation: Boolean,
            onConfirmSuccess: () -> Unit,
            onConfirmFailure: (String) -> Unit,
            defaultFailCause: String = DEFAULT_CONFIRM_SIGNUP_FAIL_CAUSE,
        ) {
            // create a cognito user through the user pool
            val cognitoUser = createUserPool(context).getUser(userId)

            // set up callbacks for sign-up confirmation
            val confirmCallback = object : GenericHandler {
                override fun onSuccess() {
                    Timber.tag(DEBUG_TAG).d("confirm successfully!")
                    onConfirmSuccess()
                }

                override fun onFailure(exception: Exception?) {
                    Timber.tag(DEBUG_TAG).e("confirmation failed: ${exception?.message}")
                    val failCause = exception?.message ?: defaultFailCause
                    onConfirmFailure(failCause)
                }
            }

            // confirm sign-up in background
            cognitoUser.confirmSignUpInBackground(confirmationCode, forcedAliasCreation, confirmCallback)
        }

        /**
         * This static method performs login request on a background thread.
         *
         * There are 3 scenarios:
         *  - (1) The tokens (Id, Access and Refresh) are cached on the device
         *  - (2) No valid tokens cached on the device
         *  - (3) All other error scenarios
         *
         *  For case (1), if the Id and Access tokens are present and they are valid, the [AuthenticationHandler.onSuccess]
         *  will be called with a [CognitoUserSession] that has reference to the valid token; otherwise,
         *  if the Id and Access tokens are expired, and if there is a valid refresh token, a network call is made
         *  to get new Id and Access tokens. If valid Id and Access tokens are retrieved, they are cached on the device
         *  and again, [AuthenticationHandler.onSuccess] will be called. The user is signed-in for this case.
         *
         *  For case (2), the callback method [AuthenticationHandler.getAuthenticationDetails] will be called where the
         *  [AuthenticationContinuation.authenticationDetails] will need to be supplied to continue the SignIn operation.
         *
         *  For case (3), [AuthenticationHandler.onFailure] will be called with the type and message of the exception
         *  and it is the responsibility of the caller to handle the exceptions appropriately.
         */
        @JvmStatic
        fun requestLogIn(
            context: Context,
            userId: String,
            onLoginSuccess: (CognitoUserSession) -> Unit,
            onLoginFailure: (String) -> Unit,
            onAuthenticationDetailsRequest: (AuthenticationContinuation) -> Unit,
            onMFACodeRequest: (MultiFactorAuthenticationContinuation) -> Unit,
            onAuthChallengeRequest: (ChallengeContinuation) -> Unit,
            defaultFailCause: String = DEFAULT_SIGN_IN_FAIL_CAUSE,
        ) {
            // create the cognito user associated with the userId through the user pool
            val cognitoUser = createUserPool(context).getUser(userId)

            // set up login callbacks
            val authenticationHandler = object : AuthenticationHandler {
                override fun onSuccess(userSession: CognitoUserSession?, newDevice: CognitoDevice?) {
                    Timber.tag(DEBUG_TAG)
                        .d("logged in successfully! username<${userSession?.username}>")
                    if (userSession == null) {
                        onLoginFailure(defaultFailCause)
                    } else {
                        // Sign-in was successful, cognitoUserSession will contain tokens for the user
                        onLoginSuccess(userSession)
                    }
                }

                override fun getAuthenticationDetails(
                    authenticationContinuation: AuthenticationContinuation?,
                    userId: String?
                ) {
                    Timber.tag(DEBUG_TAG).d("callback getAuthenticationDetails gets called")
                    if (authenticationContinuation == null) {
                        onLoginFailure(defaultFailCause)
                    } else {
                        onAuthenticationDetailsRequest(authenticationContinuation)
                    }
                }

                override fun getMFACode(continuation: MultiFactorAuthenticationContinuation?) {
                    Timber.tag(DEBUG_TAG).d("callback getMFACode gets called")
                    if (continuation == null) {
                        onLoginFailure(defaultFailCause)
                    } else {
                        onMFACodeRequest(continuation)
                    }
                }

                override fun onFailure(exception: Exception?) {
                    Timber.tag(DEBUG_TAG).e("login failed: ${exception?.message}")
                    val failCause = exception?.message ?: defaultFailCause
                    onLoginFailure(failCause)
                }

                override fun authenticationChallenge(continuation: ChallengeContinuation?) {
                    Timber.tag(DEBUG_TAG).d("callback authenticationChallenge gets called")
                    if (continuation == null) {
                        onLoginFailure(defaultFailCause)
                    } else {
                        onAuthChallengeRequest(continuation)
                    }
                }
            }
            cognitoUser.getSessionInBackground(authenticationHandler)
        }

        @JvmStatic
        fun requestResendSignUpConfirmation(
            context: Context,
            userId: String,
            onResendConfirmationSuccess: (CognitoUserCodeDeliveryDetails) -> Unit,
            onResendConfirmationFailure: (String) -> Unit,
            defaultFailCause: String = DEFAULT_RESEND_CONFIRMATION_FAIL_CAUSE,
        ) {
            // obtain the cognito user
            val cognitoUser = createUserPool(context).getUser(userId)

            // set up callbacks
            val verificationHandler = object : VerificationHandler {
                override fun onSuccess(verificationCodeDeliveryMedium: CognitoUserCodeDeliveryDetails?) {
                    Timber.tag(DEBUG_TAG).d("resend sign-up confirmation code succeeded")
                    if (verificationCodeDeliveryMedium == null) {
                        onResendConfirmationFailure(DEFAULT_RESEND_CONFIRMATION_FAIL_CAUSE)
                    } else {
                        onResendConfirmationSuccess(verificationCodeDeliveryMedium)
                    }
                }

                override fun onFailure(exception: Exception?) {
                    Timber.tag(DEBUG_TAG).e("failed to resend sign-up confirmation code: ${exception?.message}")
                    val failCause = exception?.message ?: defaultFailCause
                    onResendConfirmationFailure(failCause)
                }
            }

            // request resend sign up confirmation in background
            cognitoUser.resendConfirmationCodeInBackground(verificationHandler)
        }

        @JvmStatic
        fun requestUserAttributes(
            context: Context,
            userId: String,
            onGetAttributesSuccess: (CognitoUserDetails) -> Unit,
            onGetAttributesFailure: (String) -> Unit,
            defaultFailCause: String = DEFAULT_GET_ATTRIBUTES_FAIL_CAUSE
        ) {
            // obtain the cognito user
            val cognitoUser = createUserPool(context).getUser(userId)

            // set up callback
            val getDetailsHandler = object: GetDetailsHandler {
                override fun onSuccess(cognitoUserDetails: CognitoUserDetails?) {
                    if (cognitoUserDetails == null) {
                        onGetAttributesFailure(defaultFailCause)
                    }
                    else {
                        Timber.tag(DEBUG_TAG).d("get user attributes succeeded: ${cognitoUserDetails.attributes}")
                        onGetAttributesSuccess(cognitoUserDetails)
                    }
                }

                override fun onFailure(exception: Exception?) {
                    Timber.tag(DEBUG_TAG).e("failed to get user attributes: ${exception?.message}")
                    val failCause = exception?.message ?: defaultFailCause
                    onGetAttributesFailure(failCause)
                }

            }

            // request user attribute
            cognitoUser.getDetailsInBackground(getDetailsHandler)
        }

        @JvmStatic
        fun getCurrentUserId(context: Context): String? {
            return createUserPool(context).currentUser.userId
        }

        @JvmStatic
        fun requestSignOut(
            context: Context,
            userId: String,
        ) {
            // obtain the cognito user
            val cognitoUser = createUserPool(context).getUser(userId)

            // request sign out
            cognitoUser.signOut()
        }

        /**
         * Request the identity id of the user associated to this Credentials Provider.
         * Must NOT be called in the UI thread.
         */
        @JvmStatic
        fun obtainIdentityId(
            credentialsProvider: CognitoCachingCredentialsProvider,
            onDone: (String) -> Unit, onFailure: (String) -> Unit
        ) {
            val getIdRequest = GetIdRequest()
            getIdRequest.logins = credentialsProvider.logins
            getIdRequest.identityPoolId = CognitoConfig.IDENTITY_POOL_ID
            val identityId = try {
                AmazonCognitoIdentityClient(credentialsProvider).getId(getIdRequest).identityId
            } catch (exception: AmazonServiceException) {
                onFailure(exception.errorCode)
                ""
            } catch (exception: AmazonClientException) {
                onFailure(exception.message ?: DEFAULT_GET_IDENTITY_FAIL_CAUSE)
                ""
            }
            onDone(identityId)
        }
    } // !companion object
}